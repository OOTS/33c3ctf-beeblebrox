#!/usr/bin/python3

from hashlib import sha256
from server import TARGET_MSG, S, MODULUS, encode, decode, extended_gcd, modinv, SEPARATOR, proof_of_work_okay
import server
import socket
import math
import random
import sys
import os.path as path
import pickle
from time import time

TARGET = ('78.46.224.72', 2048)
TARGET = ('localhost', 2048)

def is_prime(n, confidence=128):
	return miller_rabin_primality_test(n, confidence)

def miller_rabin_primality_test(n, confidence):
	
	"""Miller-Rabin primality test. n: Number to be tested. confidence: expected confidence level."""
	
	# get rid of a few special cases
	if n <= 1: return False
	if n == 2 or n == 3: return True
	if n % 2 == 0: return False
	
	# split up n - 1
	r = 0
	d = n - 1
	while (d % 2 == 0):
		r += 1
		d //= 2
	assert((2**r) * d == n - 1)
	
	# if n is prime, then the group order is (2**r) * d.
	# otherwise, it's probably lower
	
	for _ in range(confidence):
		
		a = random.randint(2, n - 2)
		if gcd(n, a) != 1:
			return False
		b = pow(a, d, n)
		if b == 1 or b == n - 1: continue
		
		for i in range(r):
			b = pow(b, 2, n)
			if b == 1:
				return False
			if b == n - 1:
				break
		
		# if n is a prime, then a**((2**r)*d) _must_ be 1 (mod n),
		# because (2**r) * d == n - 1.
		# if that is not the case by now, then n can't be prime.
		if i == r - 1 and b != 1:
			return False
	
	# If we couldn't find a witness for the compositeness of n, then
	# let's assume n is prime.
	return True

def gcd(a, b):
	
	"""Returns the greatest common divisor of a and b.
	The gcd is defined as the largest integral number g which divides both a and b.
	If a and b are equal to zero, there is no gcd, and this method raises an exception."""
	
	def _gcd(a, b):
		if b == 0:
			return a
		else:
			return _gcd(b, a % b)
	
	if a == 0 and b == 0:
		raise ValueError("There is no gcd for a = b = 0")
	if a < 0:
		a = abs(a)
	if b < 0:
		b = abs(b)
	if a < b:
		a, b = b, a
	return _gcd(a, b)

def sieve_of_eratosthenes(n):
	# set up the "array" of booleans.
	# TODO: maybe a proper bitfield would be faster and more efficient than a dict.
	d = dict((i, True) for i in range(2, n + 1))
	
	for i in range(2, int(math.floor(math.sqrt(n))) + 1):
		if d[i] == True:
			for j in range(2*i, n+1, i):
				d[j] = False
	
	r = [i for i in d if d[i]]
	return r

def recv_until(s, string):
	buf = bytearray()
	while buf.find(string) == -1:
		buf += s.recv(1)
	return buf

def shamirs_trick(a, b, f, e, n):
	
	"""Given that a**f = b**e (mod n) and
	gcd(e, f) = 1,
	returns an x such that x**e = a (mod n)."""
	
	# check inputs
	a = a % n
	b = b % n
	assert(pow(a,f,n) == pow(b,e,n))
	g, s, t = extended_gcd(e, f)
	assert(g == 1)
	
	# consider that (all equations modulo n):
	# (a^s * b^t)^e = a^(se) * b^(te)
	#	= a^(se) * (b^e)^t
	#	= a^(se) * (a^f)^t     since a^f = b^e mod n
	#	= a^(se) * a^(tf)
	#	= a^(se + tf)
	#	= a^1                  since se + tf = 1, by the property of the extended euclidean algorithm
	#	= a
	
	# s or t might be negative, and python's pow() does not like negative exponents
	# for modular exponentiation. So let's fix that:
	if s < 0:
		base1 = modinv(a, n)
		s = -s
	else:
		base1 = a
	if t < 0:
		base2 = modinv(b, n)
		t = -t
	else:
		base2 = b
	
	# return
	result = (pow(base1, s, n) * pow (base2, t, n)) % n
	assert(pow(result, e, n) == a)
	return result

def store(obj, name):
	f = open(name + ".pickle", "wb")
	pickle.dump(obj, f)
	f.close()

def load(name):
	f = open(name + ".pickle", "rb")
	obj = pickle.load(f)
	f.close()
	return obj
	
def create_proof_of_work(task):
	print("Creating proof of work for {}".format(task))
	for i in range(0, 2**32):
		if i % 100000 == 0: print(i)
		if proof_of_work_okay(task, i):
			print("Solution: {}".format(i))
			return i
	raise ValueError("could not create proof of work")


try:
	primes = load("primes")
except:
	primes = sieve_of_eratosthenes(2**25)
	store(primes, "primes")

def factor(n, confidence = 128):
	
	""" Best effort factorization with trial division.
	Tries to find small factors of n.
	
	This returns two elements: a dict of all prime factors of n that were
	found and a yet-unfactored "remainder".
	The dict of prime factors contains the respective primes as keys and the respective power as value.
	(Primes of power 0 are ommitted from the dict.)
	For example, if factoring 12, the result would be:
	{2: 2, 3: 1}, 1
	because pow(2, 2) * pow(3, 1) == 12. The 1 being returned as the second value (not in the dict, but after the dict) means that 12 has been fully factored.
	"""
	
	if n < 1:
		raise ValueError("can not factor non-positive number")
		
	r = dict()
	for p in primes:
		t = 0
		while n % p == 0:
			t += 1
			n //= p
		if t > 0:
			r[p] = t
		if n == 1:
			break
	# if we are done with all primes from the list, we can still check if 
	# the result is just another prime...
	if is_prime(n, confidence):
		r[n] = 1
		return r, 1
	else:
		return r, n
		

def has_small_factors(n, bound):
	factors, remainder = factor(n, 128)
	if remainder == 1:
		test = lambda x: x < bound
		if (all(map(test, factors))):
			return factors
		else:
			return False
	else:
		return False

# The target counter is the counter used with TARGET_MSG.
def get_target_counter():
	try:
		target_counter = load("target_counter")
	except:
		print("Looking for smooth hash value.")
		start = time()
		for i in range(0, 2**20):
			if (i % 100) == 0: print(i)
			h = server.hash(TARGET_MSG, i)
			if h % 2 == 0: continue
			f = has_small_factors(h, 2**27)
			if f != False:
				print(i, f)
				break
		target_counter = i
		end = time()
		print("This took " + str(end - start) + " seconds.")
		store(target_counter, "target_counter")
	
	return target_counter

def get_auxiliary_counters(factors):
	try:
		counter_for = load("counter_for")
		print(counter_for)
	except:
		
		print("Looking for hash values sharing prime factors with the target hash: {}".format(target_hash))
		print(factors)
		start = time()
		
		counter_for = dict.fromkeys(p**factors[p] for p in factors)
		def _got_factor(counter, gcd, counter_for):
			if gcd in counter_for:
				# the gcd is equal to one of the factors
				if counter_for[gcd] == None:
					counter_for[gcd] = counter
					print("got counter {} for prime power {}".format(counter, gcd))
			else:
				# this is unlikely, but might happen
				return
				# the gcd contains _two or more_ factors of the target hash value
				# 
				temp, remainder = factor(gcd)
				 # we know all factors of the hash value, so we must know all factors of the gcd of the target hash value with every other number
				assert(remainder == 1)
				for f in temp:
					print(f)
					_got_factor(counter, f, counter_for)
		
		for i in range(0, 2**30):
			if i % 100000 == 0:
				print(i)
			h = server.hash(other_message, i)
			if h % 2 == 0:
				continue
			g = gcd(h, target_hash)
			if g > 1:
				_got_factor(i, g, counter_for)
				if all( counter_for[x] != None for x in counter_for ):
					break
		
		end = time()
		store(counter_for, "counter_for")
		print("Found all factors after {} seconds.".format(end - start))
	
	return counter_for

def get_signatures(counter_for):
	try:
		signature_for = load("signature_for")
	except:
		signature_for = dict()
	
	missing_primes = counter_for.keys() - signature_for.keys()
	if len(missing_primes) > 0:
		try:
			print("Starting to request signatures...")
			for p in missing_primes:
				challenge = s.recv(10).decode('ASCII')
				print("Trying to get a signature for prime {}".format(p))
				proof_of_work = create_proof_of_work(challenge)
				m = encode(proof_of_work, 4) + (SEPARATOR + other_message + SEPARATOR).encode('ASCII') + encode(counter_for[p], 16) + b"\n"
				s.send(m)
				recv_until(s, b"Here you are, darling!\n")
				buf = recv_until(s, b"\n")
				assert(buf.endswith(b"\n"))
				buf = buf[0:len(buf) - 1]
				signature_for[p] = decode(buf, 0, 2**2048)
				recv_until(s, b"Want another one? ;) (")
		finally:
				store(signature_for, "signature_for")
	
	return signature_for

if __name__ == "__main__":
	
	sys.setrecursionlimit(2000)
	
	# STEP 1: Look for a counter, such that hash(TARGET_MSG, counter) is smooth.
	target_counter = get_target_counter()
	print("Using target counter:", target_counter)
	target_hash = server.hash(TARGET_MSG, target_counter)
	factors, remainder = factor(target_hash)
	print("factorization: ")
	print(factors)
	assert(remainder == 1)
	
	# STEP 2: For each prime power dividing target_hash, find a 
	# message and counter such that
	# hash(message, counter) contains the prime power.
	other_message = "foobarbaz"
	counter_for = get_auxiliary_counters(factors)
	assert( all(counter_for[x] != None for x in counter_for) )
	
	# store the hash values for the auxiliary counters
	hash_for = dict()
	for p in counter_for:
		hash_for[p] = server.hash(other_message, counter_for[p])
	
	# connect to the server
	print("Connecting...")
	s = socket.create_connection(TARGET)
	buf = bytearray()
	recv_until(s, b"Want an autograph? (")
	
	# STEP 3: for each prime power dividing the target_hash value,
	# get a signature for a hash value that contains the same prime power.
	signature_for = get_signatures(counter_for)
	print("Got signatures")
	
	# STEP 4: for each prime power p dividing target_hash, obtain a
	# p-th root of S.
	roots_of_s = dict()
	for p in counter_for:
		assert(hash_for[p] % p == 0)
		roots_of_s[p] = pow(signature_for[p], hash_for[p] // p, MODULUS)
		assert(pow(roots_of_s[p], p, MODULUS) == S)
	
	# STEP 5: combine the p-th roots of S to obtain a signature for the
	# target_hash and thus for TARGET_MSG.
	current_exponent = 1
	current_base = S
	for p in roots_of_s:
		current_base = shamirs_trick(current_base, roots_of_s[p], current_exponent, p, MODULUS)
		current_exponent *= p
		assert(pow(current_base, current_exponent, MODULUS) == S)
	assert(current_exponent == target_hash)
	signature = current_base
	
	# submit the solution to the server
	s.send(b"Resign!\n")
	recv_until(s, b"Why? (")
	challenge = s.recv(10).decode('ASCII')
	proof_of_work = create_proof_of_work(challenge)
	msg = encode(proof_of_work, 4)
	msg += (SEPARATOR + TARGET_MSG + SEPARATOR).encode('ASCII')
	msg += encode(target_counter, 4)
	msg += SEPARATOR.encode('ASCII')
	msg += encode(signature, 256)
	msg += b"\n"
	s.send(msg)
	
	# print the server's answer
	recv_until(s, b"flag")
	buf = s.recv(2048).decode('ASCII')
	print(buf)
	
	s.close()
